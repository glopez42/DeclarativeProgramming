
@node codigo, References, Top, Top
@comment node-name, next, previous, up
@unnumbered codigo

Este modulo define dos programas, sumlists/4 y square_lists/3.

Para el primero, dado un numero N par, se devuelven dos listas L1 y L2 que contienen entre las dos los números de Peano de 1 a N y cuya suma es la misma, S. 
@subsection Ejemplos de uso: 
@enumerate  
@item Ej: 
@smallexample 

?- sumlists(s(s(s(s(0)))),L1,L2,S).

L1 = [s(s(s(0))),s(s(0))],
L2 = [s(s(s(s(0)))),s(0)],
S = s(s(s(s(s(0))))) ? 
yes
?-
@end smallexample 
@item Ej: 
@smallexample 

?- sumlists(s(s(s(s(s(s(s(s(0)))))))),L1,L2,S).

L1 = [s(s(s(s(s(s(s(0))))))),s(s(s(s(s(0))))),s(s(s(s(0)))),s(s(0))],
L2 = [s(s(s(s(s(s(0)))))),s(s(s(s(s(s(s(s(0)))))))),s(s(s(0))),s(0)],
S = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))) ? 
yes
?-
@end smallexample 
@end enumerate 

Por otra parte, para square_lists/4, dado un numero N, se devuelve una matriz cuadrada de N*N que contiene todos los numeros de Peano del 1 a N² y cuyas filas suman lo mismo. 
@subsection Ejemplos de uso: 
@enumerate  
@item Ej: 
@smallexample 

?- square_lists(s(s(0)),SQ,S).

S = s(s(s(s(s(0))))),
SQ = [[s(s(s(0))),s(s(0))],[s(s(s(s(0)))),s(0)]] ? 

yes
?-
@end smallexample 
@item Ej: 
@smallexample 

?- square_lists(s(s(s(0))),SQ,S).

S = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))),
SQ = [[s(s(s(s(s(s(s(s(0)))))))),s(s(s(s(0)))),s(s(s(0)))],
     [s(s(s(s(s(s(s(0))))))),s(s(s(s(s(s(0)))))),s(s(0))],
     [s(s(s(s(s(s(s(s(s(0))))))))),s(s(s(s(s(0))))),s(0)]] ? 

yes
?-
@end smallexample 
@end enumerate 

Mas adelante se muestran los predicados y propiedades que se han utilizado. 

@section Usage and interface
@cartouche
@itemize @bullet
@item @b{Library usage:}

@code{:- use_module(/home/guilogar/UPM/6semestre/ProDeclarativa/sumlistPeano/codigo.pl).}
@item @b{Exports:}

@itemize @minus
@item @i{Predicates:}

@code{alumno_prode/4}, @code{plus/3}, @code{nums/2}, @code{sumlist/2}, @code{choose_one/3}, @code{perm/2}, @code{split/3}, @code{sumlists/4}, @code{make_matrix/3}, @code{take_N/4}, @code{check_sum/2}, @code{times/3}, @code{exp/3}, @code{greater_zero/1}, @code{square_lists/3}.
@item @i{Properties:}

@code{nat/1}, @code{lista/1}.
@end itemize
@end itemize
@end cartouche
@section Documentation on exports
@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{alumno_prode/4 (pred)}}}
@temp
@end iftex
@deffn PREDICATE alumno_prode/4:
No further documentation available for this predicate.
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{nat/1 (prop)}}}
@temp
@end iftex
@deffn PROPERTY nat/1:

@b{Usage:} @code{nat(N)}

Cierto si @code{N} es un numero natural. 
@smallexample 
nat(0).
nat(s(X)) :-
    nat(X).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{lista/1 (prop)}}}
@temp
@end iftex
@deffn PROPERTY lista/1:

@b{Usage:} @code{lista(L)}

Cierto si @code{L} es una lista. 
@smallexample 
lista([]).
lista([_1|Y]) :-
    lista(Y).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{plus/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE plus/3:

@b{Usage:} @code{plus(A,B,C)}

Cierto si @code{A} + @code{B} = @code{C}. 
@smallexample 
plus(X,0,X) :-
    nat(X).
plus(X,s(Y),s(Z)) :-
    plus(X,Y,Z).
@end smallexample
@itemize @minus
@end itemize

@b{Other properties:} 

@b{Test:} @code{plus(A,B,C)}

2 + 1 = 3
@itemize @minus
@item @i{If the following properties hold at call time:}

@code{A=s(s(0))}
@iftex
@hfill
@end iftex
 (@code{= /2})

@code{B=s(0)}
@iftex
@hfill
@end iftex
 (@code{= /2})

@i{then the following properties should hold upon exit:}

@code{C=s(s(s(0)))}
@iftex
@hfill
@end iftex
 (@code{= /2})

@i{then the following properties should hold globally:}

All the calls of the form @code{plus(A,B,C)} do not fail.
@iftex
@hfill
@end iftex
 (@code{not_fails/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{nums/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE nums/2:

@b{Usage:} @code{nums(N,L)}

Cierto si @code{L} es una lista descendente de @code{N} a 1. 
@smallexample 
nums(0,[]).
nums(s(N),[s(N)|Np]) :-
    nums(N,Np).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sumlist/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sumlist/2:

@b{Usage:} @code{sumlist(L,N)}

Cierto si @code{N} es la suma de elementos de @code{L}. 
@smallexample 
sumlist([],0).
sumlist([N|Np],S) :-
    sumlist(Np,Sp),
    plus(N,Sp,S).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{choose_one/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE choose_one/3:

@b{Usage:} @code{choose_one(E,L,R)}

Cierto si @code{R} es igual a @code{L} sin el elemento @code{E}. 
@smallexample 
choose_one(E,[E|Lp],Lp) :-
    lista(Lp).
choose_one(E,[X|Lp],[X|Rp]) :-
    choose_one(E,Lp,Rp).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{perm/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE perm/2:

@b{Usage:} @code{perm(L,Lp)}

Cierto si @code{Lp} es una permutacion de @code{L}. 
@smallexample 
perm([],[]).
perm([X|R],L) :-
    perm(R,Lp),
    choose_one(X,L,Lp).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{split/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE split/3:

@b{Usage:} @code{split(L,Lp,Li)}

Cierto si @code{Lp} tiene los elementos de posicion par de @code{L}, y @code{Li}, los de posicion impar. 
@smallexample 
split([],[],[]).
split([X1,X2|Xn],[X1|Xp],[X2|Xpp]) :-
    split(Xn,Xp,Xpp).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{sumlists/4 (pred)}}}
@temp
@end iftex
@deffn PREDICATE sumlists/4:

@b{Usage:} @code{sumlists(N,L1,L2,S)}

Cierto si @code{L1} y @code{L2} contienen entre las dos los naturales de @code{N} hasta 1, y ambas suman lo mismo.
@smallexample 
sumlists(N,L1,L2,S) :-
    nums(N,L),
    perm(L,Lp),
    split(Lp,L1,L2),
    sumlist(L1,S),
    sumlist(L2,S).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{make_matrix/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE make_matrix/3:

@b{Usage:} @code{make_matrix(L,N,M)}

Cierto si @code{M} es una matriz de @code{N}*@code{N} formada por los elementos de @code{L}. 
@smallexample 
make_matrix([],_1,[]).
make_matrix(Lista,N,[Fila|Filas]) :-
    take_N(Lista,N,Fila,Rest),
    make_matrix(Rest,N,Filas).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{take_N/4 (pred)}}}
@temp
@end iftex
@deffn PREDICATE take_N/4:

@b{Usage:} @code{take_N(L1,N,L2,Resto)}

Cierto si @code{L2} es una lista formada por los primeros @code{N} elementos de @code{L1}. @code{Resto} contiene el resto de elementos de @code{L1}. 
@smallexample 
take_N(Rest,0,[],Rest).
take_N([Elem|Lista],s(N),[Elem|Lista2],Rest) :-
    take_N(Lista,N,Lista2,Rest).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{check_sum/2 (pred)}}}
@temp
@end iftex
@deffn PREDICATE check_sum/2:

@b{Usage:} @code{check_sum(M,S)}

Cierto si la suma de todas las filas de @code{M} suman @code{S}. 
@smallexample 
check_sum([],_1).
check_sum([Fila|Filas],Sum) :-
    sumlist(Fila,Sum),
    check_sum(Filas,Sum).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{times/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE times/3:

@b{Usage:} @code{times(A,B,C)}

Cierto si @code{A} * @code{B} = @code{C} 
@smallexample 
times(X,0,0) :-
    nat(X).
times(X,s(Y),Z) :-
    times(X,Y,W),
    plus(X,W,Z).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{exp/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE exp/3:

@b{Usage:} @code{exp(Exp,N,S)}

Cierto si @code{N}^@code{Exp} = @code{S} 
@smallexample 
exp(0,X,s(0)) :-
    nat(X).
exp(s(N),X,Y) :-
    exp(N,X,W),
    times(W,X,Y).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{greater_zero/1 (pred)}}}
@temp
@end iftex
@deffn PREDICATE greater_zero/1:

@b{Usage:} @code{greater_zero(N)}

Cierto si @code{N} es un natural mayor que 0. 
@smallexample 
greater_zero(s(0)).
greater_zero(s(N)) :-
    greater_zero(N).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{square_lists/3 (pred)}}}
@temp
@end iftex
@deffn PREDICATE square_lists/3:

@b{Usage:} @code{square_lists(N,SQ,S)}

Cierto si @code{SQ} es una matriz de @code{N}*@code{N}, cuyas filas suman @code{S}, y entre todas contienen los numeros de @code{N}^2 hasta 1. 
@smallexample 
square_lists(N,SQ,S) :-
    greater_zero(N),
    exp(s(s(0)),N,N2),
    nums(N2,Lista),
    perm(Lista,ListaP),
    make_matrix(ListaP,N,SQ),
    check_sum(SQ,S).
@end smallexample
@itemize @minus
@end itemize
@end deffn
@sp 1

@section Documentation on imports
This module has the following direct dependencies:
@itemize @minus
@item @i{Internal (engine) modules:}

@code{term_basic}, @code{arithmetic}, @code{atomic_basic}, @code{basiccontrol}, @code{exceptions}, @code{term_compare}, @code{term_typing}, @code{debugger_support}, @code{basic_props}.
@item @i{Packages:}

@code{prelude}, @code{initial}, @code{condcomp}, @code{assertions}, @code{assertions/assertions_basic}.
@end itemize
